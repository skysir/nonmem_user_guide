! Example sde9.ctl, how to set up using the SDE routines.
!  $PROBLEM PK ODE HANDS ON ONE
!
!$INPUT ID TIME DV AMT CMT FLAG MDV SDE
!
!$DATA   sde9.csv
!        IGNORE=@
!
!$SUBROUTINE ADVAN6 TOL=9 DP OTHER=SDE.f90
!
!; nde=number of base equations, ncmt=number of observation compartments
!$ABBR DECLARE SGW(3) ; need at least ncmt of these
!$MODEL 
!       COMP = (CENTRAL); there are nde base states
!       COMP = (DFDX1)  ; need ncmt observation compartments
!       COMP = (DPDT11) ; Will need (nde+1)*nde/2 of these
!
!$PK
!  IF(NEWIND.NE.2) OT = 0
!   
!  MU_1  = THETA(1)
!  CL    = EXP(MU_1+ETA(1)) 
!  MU_2  = THETA(2)
!  VD    = EXP(MU_2+ETA(2))
!  SGW1 = THETA(4)
!
!
!$DES
! FIRSTEM=1
! DADT(1) = - CL/VD*A(1)
!; NEXT DERIVATIVES ARE ACUALLY PREDICTIVE VALUES FOR COMPARTMENTS 1 AND 2, RESPECTIVELY
!;  Derivatives of these with respect to A() will be calculated symbolically by DES routine created by NMTRAN
! DADT(2) = A(1)/VD
!; DUMMY PLACEMENT FOR DERIVATIVES OF THE STOCHASTIC ERROR SYSTEM.  THESE ARE FILLED OUT BY SDE_DER
!SGW(1)=SGW1
!;  the DA() array THEN contains all derivatives of DADT (=DXDT) with respect to A(=X).
!; number of base model derivative equations (nde)=1, Number of compartments (ncmt)=1. 
!; DA is a reserved array, dimensioned DA(IR,*)
!"LAST
!"      CALL SDE_DER(DADT,A,DA,IR,SGW,1.0d+00,1.0d+00)
! 
!$ERROR (OBS ONLY)
!  
!     IPRED = A(1)/VD
!     IRES  = DV - IPRED
!     W     = THETA(3)
!     IWRES = IRES/W
!     WS=1000.0
!; CENTRAL COMPARTMENT, PLASMA LEVELS
!; EPS(1) = USER MODEL ERROR CONTRIBUTION
!; EPS(2) = STOCHASTIC ERROR CONTRIBUTION.  THE WS IS JUST A PLACEHOLDER COEFFICIENT.  SDE_CADD WILL REPLACE THIS
!; WITH THE CORRECT VALUE
!     Y     = IPRED+W*EPS(1) + WS*EPS(2)
!; SDE_CADD WILL EVALUATE THE TRUE COEFFICIENTS (WS) TO THE STOCHASTIC COMPONENTS.
!;  In general, if you have nmcmt observation compartments, then first ncmt EPS() will pertain to
!; measurement error, and the second ncmt set of EPS() will pertain to stochastic errors.
!;  This means you cannot have L2 type correlations, and prop+additive should be packaged into a single EPS().
!;  For two obervations, you may have:
!;  IF(CMT==1) THEN
!;  IPRED=A(1)/V
!;  W=SQRT(THETA((5)*THETA(5)*IPED*IPRED+THETA(6)*THETA(6))
!;  Y=IPRED+W*EPS(1)+WS*EPS(3)
!;  ENDIF
!;  IF(CMT==2) THEN
!;  IPRED=A(2)/V
!;  W=SQRT(THETA((7)*THETA(7)*IPED*IPRED+THETA(8)*THETA(8))
!;  Y=IPRED+W*EPS(2)+WS*EPS(4)
!;  ENDIF
!
!; Number of compartments=1, number of base model derivative equations=1
!"LAST
!"       CALL SDE_CADD(A,HH,TIME,DV,CMT,1.0D+00,1.0D+00,SDE)
!
!
!
!$THETA (0,2.3)               ;1 CL
!$THETA (0,3.5)               ;2 VD
!$THETA (0, 2)               ;4 SIGMA
!$THETA (0,1) ; SGW1
!
!$OMEGA 0.1                  ;1 CL
!$OMEGA 0.01                 ;2 VD
!
!$SIGMA (1 FIX) (1 FIX)               ; PK
!
!$EST METHOD=ITS INTERACTION LAPLACE NUMERICAL SLOW NOABORT PRINT=1 CTYPE=3 SIGL=5
!$EST METHOD=IMP INTERACTION NOABORT SIGL=5 PRINT=1 IACCEPT=1.0 CTYPE=3
!$EST MAXEVAL=9999 METHOD=1 LAPLACE INTER NOABORT NUMERICAL SLOW NSIG=3 PRINT=1 MSFO=sde9.msf SIGL=9
!$COV MATRIX=R UNCONDITIONAL
!
!$TABLE ID TIME FLAG AMT CMT IPRED IRES IWRES
!       ONEHEADER NOPRINT FILE=sde9.fit

      SUBROUTINE SDE_DER(DXDT,X,A,IR,SGW,DNNDE,DNNCMT)
      USE PRCOM_REAL,  ONLY: PAR=>G3
      USE NMPRD_INT, ONLY: MFIRST=>IFRSTDER
      IMPLICIT NONE
      INTEGER NDE,NCMT
      PARAMETER (NDE=30,NCMT=30)
      INTEGER NCMT_NDE,NCMT_NCMT,NDE_NDE
      PARAMETER (NCMT_NDE=NCMT*NDE,NCMT_NCMT=NCMT*NCMT,NDE_NDE=NDE*NDE)
      REAL*8 DIR
      REAL*8 DXDT(*),A(IR,*),SGW(*),X(*),DNNDE,DNNCMT
      INTEGER IR,I,KK,J,IRR,NNDE,NNCMT
! A(I,J)=D(DXDT(I))/D(X(J))
      REAL*8 C(NCMT,NDE),R(NCMT,NCMT),P(NDE,NDE),K(NDE,NCMT),SGW2(NDE)
      REAL*8 WORK1(NCMT,NCMT),WORK2(NDE),TIMEPREV
      COMMON /SDE_COMMON/ C,R,P,K,TIMEPREV,SGW2,WORK1,WORK2,IRR
      DATA C /NCMT_NDE*0.0D+00/
      DATA R /NCMT_NCMT*0.0D+00/
      DATA P /NDE_NDE*0.0D+00/
      DATA K /NCMT_NDE*0.0D+00/
      DATA TIMEPREV /-1.0D+00/
      DATA SGW2 /NDE*0.0D+00/
      DATA WORK1 /NCMT_NCMT*0.0D+00/
      DATA WORK2 /NDE*0.0D+00/
      DATA IRR /0/
! NEXT FOUR LINES CALCULATES DPDT= AxP + PxA' + SGWxSGW'      

      MFIRST=1
      NNDE=DNNDE
      NNCMT=DNNCMT

      KK=NNDE+NNCMT
      DO I=1,NNDE
      SGW2(I)=SGW(I)
      DO J=1,I
      KK=KK+1
      P(I,J)=X(KK)
      ENDDO
      ENDDO

      CALL ZEROMAT(WORK1,NNDE,NNDE,NCMT) !ZERO ACCUMULATOR ARRAY WORK1
      CALL MATXMAT_ADD(A,NNDE,NNDE,IR,P,NNDE,NDE,WORK1,NCMT) !ADD A*P TO ACCUMULATOR
      CALL MATXMATT_ADD(P,NNDE,NNDE,NDE,A,NNDE,IR,WORK1,NCMT) !ADD P*A' TO ACCUMULATOR
      DO I=1,NNDE
      WORK1(I,I)=WORK1(I,I)+SGW(I)*SGW(I)
      ENDDO
      IRR=IR
      KK=NNDE+NNCMT
      DO I=1,NNDE
      DO J=1,I
      KK=KK+1
! ADD DPDT TO DXDT ARRAY SYSTEM, SO NUMERICAL INTEGRATOR CAN INTEGRATE IT
      DXDT(KK)=WORK1(I,J)
      ENDDO
      ENDDO
      RETURN
      END
      SUBROUTINE SDE_CADD(X,HH,TIME,DV,DCMT,DNNCMT,DNNDE,DNNSDE)
      USE SIZES,      ONLY: LVR
      USE PRCOM_REAL,  ONLY: G3,A=>DA,DP,DET
      USE NMPRD_INT, ONLY: MFIRST=>IFRSTDER
      USE PRCOM_INT, ONLY: MCOMP
      USE NMPRD_INT,  ONLY: NEPS
      USE PROCM_INT, ONLY: NEWIND=>PNEWIF                                     
      USE PROCM_REAL,ONLY: THETA=>THETAS
!      USE PROCM_INT,  ONLY: A_0FLG
!      USE PRMOD_REAL, ONLY: A_0
      USE PRCM_INT,   ONLY: MFLAG1,MFLAG2,MFLAG3,MFLAG4,MFLAG6,MFLAG7
      IMPLICIT NONE
      INTEGER NDE,NCMT,NNEPS,NNDE,NNCMT,NNSDE,I,J,KK,L,IFLAG,NOTPOS,CMT,IRR,MFIRST_OLD
      PARAMETER (NDE=30,NCMT=30,NNEPS=LVR)
      REAL*8 DNNCMT,DNNSDE,DNNDE,DCMT
      REAL*8 C(NCMT,NDE),R(NCMT,NCMT),P(NDE,NDE),K(NDE,NCMT),SGW2(NDE)
      REAL*8 WORK1(NCMT,NCMT),WORK2(NDE),OBS(NCMT)
      COMMON /SDE_COMMON/ C,R,P,K,TIMEPREV,SGW2,WORK1,WORK2,IRR
      REAL*8 X(*),DXDT(NDE),HH(*),HLS(NCMT,NCMT),HLM(NCMT,NCMT),TIME,VAR,DV,DVAL,TIMEPREV
      REAL*8 RINV(NCMT,NCMT)
      SAVE
      
!      
! NNSDE=0, BEGINNING OF SUBJECT, OR WHENEVER YOU WANT TO INITIALIZE SDE SYSTEM (SOMETIMES YOU WANT TO DO THIS
! EVEN WITHIN A SUBJECT, LIKE A NEW OCCASION)
! NNSDE=1, FIRST OBSERVATION OF PRESENT TIME.
! NNSDE=2 LAST OBSERVATION FOR PRESENT TIME.
! NNSDE=5 FIRST AND LAST OBSERVATION FOR PRESENT TIME.
! NNSDE=6, MIDDLE OBSERVAION FOR PRESENT TIME.
! THUS:
! DOSE RECORD, TIME=0, THEN NNSDE=0
! PK OBSERVATION, TIME=0.1, NNSDE=1
! PD OBSERVATION, TIME=0.1, NNSDE=6
! EFFICACY OBSERVATION, TIME=0.1, NNSDE=2  (NNSDE=2 SINCE NEXT RECORD HAS A NEW TIME)
! PK OBSERVATION, TIME=0.2, NNSDE=1
! PD OBSERVATION, TIME=0.2, NNSDE=2
! PK OBSERVATION, TIME=0.5, NNSDE=5
! PK OBSERVATION, TIME=1.0, NNSDE=5
! 

! HLS CONTAINS STOCHASTIC ERROR
! HLM CONTAINS MEASUREMENT ERROR

      MFIRST=1
      NNSDE=DNNSDE
      NNCMT=DNNCMT
      NNDE=DNNDE
      CMT=DCMT
      IF(NNSDE==0 .OR. NEWIND .NE.2) THEN
! INITIALIZE ALL, INCLUDING HLS, SO NO CARRYOVER
      DO J=1,NNCMT
      OBS(J)=0.0D+00
      DO I=1,NNCMT
      HLS(J,I)=0.0D+00
      HLM(J,I)=0.0D+00
      ENDDO
      ENDDO
      KK=NNDE+NNCMT
      DO I=1,NNDE
      DO J=1,I
      KK=KK+1
      X(KK)=0.0D+00
      P(I,J)=0.0D+00
      P(J,I)=0.0D+00
      ENDDO
      ENDDO
      MFLAG1=1 !MFLAG1=1 INDICATES CHANGE OF STATE ARRAYS X() TO INTEGRATOR.  WORKS ONLY FOR ADVAN9, ADVAN13.
      RETURN
      ENDIF
      
      IF(NNSDE==3) THEN
      KK=NNDE+NNCMT
      DO I=1,NNDE
      DO J=1,I
      KK=KK+1
      X(KK)=0.0D+00
      P(I,J)=0.0D+00
      P(J,I)=0.0D+00
      ENDDO
      ENDDO
      MFLAG1=1 !MFLAG1=1 INDICATES CHANGE OF STATE ARRAYS X() TO INTEGRATOR.  WORKS ONLY FOR ADVAN9, ADVAN13.
      RETURN
      ENDIF


      IF(NNSDE==4) THEN
      DO I=1,NNDE
      X(I)=0.0D+00
      ENDDO
      KK=NNDE+NNCMT
      DO I=1,NNDE
      DO J=1,I
      KK=KK+1
      P(I,J)=X(KK)
      P(J,I)=X(KK)
      ENDDO
      ENDDO
      MFLAG1=1 !MFLAG1=1 INDICATES CHANGE OF STATE ARRAYS X() TO INTEGRATOR.  WORKS ONLY FOR ADVAN9, ADVAN13.
      RETURN
      ENDIF



! CALL DES TO GET THE FINAL DERIVATIVE VALUES
      IF(NNSDE==1 .OR. NNSDE==5) THEN
      MFIRST_OLD=MFIRST
      MFIRST=1
      CALL DES (X,G3,TIME,DXDT,MCOMP,A,DP,DET)
      MFIRST=MFIRST_OLD
! THE X() ARRAY STARTING AT OFFSET NNDE+NNCMT CONTAIN INTEGRALS TO DPDT, THAT IS, THEY CONTAIN THE
! P ARRAY. COLLECT THEM INTO P(,)
      KK=NNDE+NNCMT
      DO I=1,NNDE
      DO J=1,I
      KK=KK+1
      P(I,J)=X(KK)
      P(J,I)=X(KK)
      ENDDO
      ENDDO

! ADD THE DFDX ARRAYS TO THE C ARRAY.
      DO I=1,NNCMT
      DO J=1,NNDE
      C(I,J)=A(I+NNDE,J)
      ENDDO
      ENDDO
      ENDIF

      IF(NNSDE==1 .OR.NNSDE==5) THEN
! EVALUATE CxPxC', PLACE IN R
      CALL ZEROMAT(R,NNCMT,NNCMT,NCMT) !ZERO RESULT ARRAY WORK1
      CALL ZEROMAT(WORK1,NNCMT,NNCMT,NCMT) !ZERO RESULT ARRAY WORK1
      CALL MATXMAT_ADD(C,NNCMT,NNDE,NCMT,P,NNDE,NDE,WORK1,NCMT) ! CALCULATE CxP, PUT IN WORK1
      CALL MATXMATT_ADD(WORK1,NNCMT,NNDE,NCMT,C,NNCMT,NCMT,R,NCMT) !CALCULATE WORK1xC' = CxPxC'

! THE STOACHSTIC ERROR PORTION OF R, STORED IN WORK1, GETS 
! CHOLESKY DEOMPOSED, AND PLACED IN HLS.  THIS HLS EVENTUALLY GETS PUT INTO HH,
! SO NONMEM CAN INCOPORATE IT INTO ITS RESIDUAL ERROR SYSTEM.
      DO I=1,NNCMT
      DO J=1,NNCMT
      WORK1(I,J)=R(I,J)
      ENDDO
      ENDDO
      CALL ONEDIAG(WORK1,NNCMT,NCMT,WORK2)
      CALL POSDEF(WORK1,NNCMT,NCMT,1)
      CALL CHOL_DECOMP(WORK1,HLS,NNCMT,NCMT,IFLAG,NOTPOS)
      CALL ZERODIAG(HLS,NNCMT,NCMT,WORK2)
      ENDIF

! ACCUMULATE WITH FOR EACH COMPARTMENT NUMBER CMT
      DO I=1,NNCMT
! COLLECT MEASUREMENT ERROR PORTION
      HLM(CMT,I)=HH(I)
      ENDDO
! HH() IS FROM 1 TO NEPS, WHERE NEPS SHOULD BE NNCMT*2
      DO I=1,NNCMT
! SEND NONMEM THE STOCHASTIC CONTRIBUTION
      HH(I+NNCMT)=HLS(CMT,I)
      ENDDO
      OBS(CMT)=DV
      TIMEPREV=TIME

      IF(NNSDE==2 .OR. NNSDE==5) THEN
! CALCULATE THE MEASUREMENT ERROR COMPONENT (s^2), AND  PLACE IN THE R ARRAY
! NOTE THAT HLM CONTAINS CHOLESKY FORM OF MEASREUEMENT ERROR,
! AND HLS CONTAINS CHOLESKY FORM OF STOCHASTIC ERROR.
! SO WE NEED TO CONSTRUCT FULL MEASUREMENT ERROR VARIANCE
      DO I=1,NNCMT
        DO J=1,I
          DVAL=0.0D+00
          DO KK=1,NNCMT   ! WE ONLY WANT MEASUREMENT ERROR CONTRIBUTION
            DO L=1,NNCMT
              DVAL=DVAL+HLM(I,KK)*VAR(KK,L,2)*HLM(J,L)
            END DO
          END DO
          R(I,J)=R(I,J)+DVAL
          R(J,I)=R(I,J)
        ENDDO
      ENDDO
   
! NOW CALCULATE K=PxC'xRINV
      CALL MATINV(R,NNCMT,NCMT,RINV,WORK1)
      CALL ZEROMAT(K,NNDE,NNCMT,NDE)
      CALL ZEROMAT(WORK1,NNDE,NNCMT,NCMT)
      CALL MATXMATT_ADD(P,NNDE,NNDE,NDE,C,NNCMT,NCMT,WORK1,NCMT)
      CALL MATXMAT_ADD(WORK1,NNDE,NNCMT,NCMT,RINV,NNCMT,NCMT,K,NCMT)
! X=X+Kx(OBS-PREDICTED).  REMEMBER, DXDT STARTING AT OFFSET NNDE CONTAINS PREDICTIVE EQUATIONS
      DO I=1,NNDE
      DVAL=0.0D+00
      DO J=1,NNCMT
      DVAL=DVAL+K(I,J)*(OBS(J)-DXDT(NNDE+J))
      ENDDO
      X(I)=X(I)+DVAL
      ENDDO       
! P=P-KxRxK'
      CALL ZEROMAT(WORK1,NNDE,NNCMT,NCMT)
      CALL MATXMAT_ADD(K,NNDE,NNCMT,NDE,R,NNCMT,NCMT,WORK1,NCMT)
      CALL MATXMATT_SUB(WORK1,NNDE,NNCMT,NCMT,K,NNDE,NDE,P,NDE)

      KK=NNDE+NNCMT
      DO I=1,NNDE
      DO J=1,I
      KK=KK+1
      X(KK)=P(I,J)
      ENDDO
      ENDDO
      MFLAG1=1 !MFLAG1=1 INDICATES CHANGE OF STATE ARRAYS X() TO INTEGRATOR.  WORKS ONLY FOR ADVAN9, ADVAN13.

      ENDIF

      RETURN
      END
      SUBROUTINE ZEROMAT(A,N,M,NDIM)
      REAL*8 A(NDIM,*)
      DO I=1,N
      DO J=1,M
      A(I,J)=0.0D+00
      ENDDO
      ENDDO
      RETURN
      END
      SUBROUTINE MATXMAT_ADD(A1,N1,N12,NDIM1,A2,N2,NDIM2,A3,NDIM3)
      REAL*8 A1(NDIM1,*),A2(NDIM2,*),A3(NDIM3,*)
      DO I=1,N1
      DO J=1,N2
      DVAL=0.0D+00
      DO K=1,N12
      DVAL=DVAL+A1(I,K)*A2(K,J)
      ENDDO
      A3(I,J)=A3(I,J)+DVAL
      ENDDO
      ENDDO
      RETURN
      END

      SUBROUTINE MATXMATT_ADD(A1,N1,N12,NDIM1,A2,N2,NDIM2,A3,NDIM3)
      REAL*8 A1(NDIM1,*),A2(NDIM2,*),A3(NDIM3,*)
      DO I=1,N1
      DO J=1,N2
      DVAL=0.0D+00
      DO K=1,N12
      DVAL=DVAL+A1(I,K)*A2(J,K)
      ENDDO
      A3(I,J)=A3(I,J)+DVAL
      ENDDO
      ENDDO
      RETURN
      END
      SUBROUTINE MATXMATT_SUB(A1,N1,N12,NDIM1,A2,N2,NDIM2,A3,NDIM3)
      REAL*8 A1(NDIM1,*),A2(NDIM2,*),A3(NDIM3,*)
      DO I=1,N1
      DO J=1,N2
      DVAL=0.0D+00
      DO K=1,N12
      DVAL=DVAL+A1(I,K)*A2(J,K)
      ENDDO
      A3(I,J)=A3(I,J)-DVAL
      ENDDO
      ENDDO
      RETURN
      END
      SUBROUTINE VECXVEC_ADD(A1,A2,N,A3,NDIM)
      REAL*8 A1(*),A2(*),A3(NDIM,*)
      DO I=1,N
      DO J=1,N
      A3(I,J)=A3(I,J)+A1(I)*A2(J)
      ENDDO
      ENDDO
      RETURN
      END

      SUBROUTINE MATINV(R,N,NDIM,RINV,WORK)
      REAL*8 R(NDIM,*),RINV(NDIM,*),WORK(NDIM,*),DETLN
      DO I=1,N
      DO J=1,N
      WORK(I,J)=R(I,J)
      ENDDO
      IF(R(I,I)==0.0D+00) WORK(I,I)=1.0D+00
      ENDDO      
      CALL INV3(WORK,N,DETLN,NDIM,IER,RINV,NOTPOS)
!      CALL INV5(WORK,N,NDIM,RINV)
      DO I=1,N
      IF(R(I,I)==0.0D+00) RINV(I,I)=0.0D+00
      ENDDO      
      RETURN
      END
      
      SUBROUTINE ONEDIAG(R,N,NDIM,WORK)
      REAL*8 R(NDIM,*),WORK(*)
      DO I=1,N
      WORK(I)=1.0D+00
      IF(R(I,I)==0.0D+00) THEN
      WORK(I)=0.0D+00
      R(I,I)=1.0D+00
      ENDIF
      ENDDO
      RETURN
      END
      
      SUBROUTINE ZERODIAG(R,N,NDIM,WORK)
      REAL*8 R(NDIM,*),WORK(*)
      DO I=1,N
      IF(WORK(I)==0.0D+00) R(I,I)=0.0D+00
      ENDDO
      RETURN
      END
      
